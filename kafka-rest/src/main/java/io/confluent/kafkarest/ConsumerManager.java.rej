diff a/kafka-rest/src/main/java/io/confluent/kafkarest/ConsumerManager.java b/kafka-rest/src/main/java/io/confluent/kafkarest/ConsumerManager.java	(rejected hunks)
@@ -149,70 +159,47 @@ public class ConsumerManager {
 
       // Note the ordering here. We want to allow overrides, but almost all the
       // consumer-specific settings don't make sense to override globally (e.g. group ID, consumer
-      // ID), and others we want to ensure get overridden (e.g. consumer.timeout.ms, which we
-      // intentionally name differently in our own configs).
+      // ID), and others we want to ensure get overridden.
       Properties props = (Properties) config.getOriginalProperties().clone();
-      props.setProperty("zookeeper.connect", zookeeperConnect);
+      props.setProperty(KafkaRestConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
       props.setProperty("group.id", group);
+
       // This ID we pass here has to be unique, only pass a value along if the deprecated ID field
       // was passed in. This generally shouldn't be used, but is maintained for compatibility.
       if (instanceConfig.getId() != null) {
         props.setProperty("consumer.id", instanceConfig.getId());
       }
-      // To support the old consumer interface with broken peek()/missing poll(timeout)
-      // functionality, we always use a timeout. This can't perfectly guarantee a total request
-      // timeout, but can get as close as this timeout's value
-      props.setProperty("consumer.timeout.ms", ((Integer) iteratorTimeoutMs).toString());
+
       if (instanceConfig.getAutoCommitEnable() != null) {
-        props.setProperty("auto.commit.enable", instanceConfig.getAutoCommitEnable());
+        props.setProperty("enable.auto.commit", instanceConfig.getAutoCommitEnable());
       } else {
-        props.setProperty("auto.commit.enable", "false");
+        props.setProperty("enable.auto.commit", "false");
       }
       if (instanceConfig.getAutoOffsetReset() != null) {
         props.setProperty("auto.offset.reset", instanceConfig.getAutoOffsetReset());
       }
-        // configure default stream
-        String defaultStream = config.getString(KafkaRestConfig.STREAMS_DEFAULT_STREAM_CONFIG);
-        if (!"".equals(defaultStream)) {
-            props.put(ConsumerConfig.STREAMS_CONSUMER_DEFAULT_STREAM_CONFIG, defaultStream);
-        }
-        
-      ConsumerConnector consumer;
+
+      // configure default stream
+      String defaultStream = config.getString(KafkaRestConfig.STREAMS_DEFAULT_STREAM_CONFIG);
+      if (!"".equals(defaultStream)) {
+        props.put(ConsumerConfig.STREAMS_CONSUMER_DEFAULT_STREAM_CONFIG, defaultStream);
+      }
+
       try {
-        if (consumerFactory == null) {
-          consumer = Consumer.createJavaConsumerConnector(new ConsumerConfig(props));
-        } else {
-          consumer = consumerFactory.createConsumer(new ConsumerConfig(props));
+        ConsumerState state = EmbeddedFormat.createConsumerState(instanceConfig.getFormat(),
+            this.config, cid, props, consumerFactory);
+
+        synchronized (this)  {
+          consumers.put(cid, state);
+          consumersByExpiration.add(state);
+          this.notifyAll();
         }
+        succeeded = true;
+        return name;
       } catch (InvalidConfigException e) {
         throw Errors.invalidConsumerConfigException(e);
       }
 
-      ConsumerState state;
-      switch (instanceConfig.getFormat()) {
-        case BINARY:
-          state = new BinaryConsumerState(this.config, cid, consumer);
-          break;
-        case AVRO:
-          state = new AvroConsumerState(this.config, cid, consumer);
-          break;
-        case JSON:
-          state = new JsonConsumerState(this.config, cid, consumer);
-          break;
-        default:
-          throw new RestServerErrorException(
-              "Invalid embedded format for new consumer.",
-              Response.Status.INTERNAL_SERVER_ERROR.getStatusCode()
-          );
-      }
-
-      synchronized (this) {
-        consumers.put(cid, state);
-        consumersByExpiration.add(state);
-        this.notifyAll();
-      }
-      succeeded = true;
-      return name;
     } finally {
       if (!succeeded) {
         synchronized (this) {
